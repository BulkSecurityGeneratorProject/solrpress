h1.text-center Kewl brunch skeleton walkthrough

p.lead.
  Angular apps are client-side apps, often single-page.
  They land their code on the client, then load on demand data from the server using AJAX.
  Unlike regular web pages (without AJAX) where all the content is generated by the server, when the content changes,
  useful indicators provided by the browser are not triggered (loading bar, error messages,...).
  Moreover, nothing indicates to the user something is happening, preventing him to diagnose an eventual error.
  Angular provides all the tools we need to address this lacks.
  Let's walk together though this boilerplate code to start an Angular app capable of communicating elegantly with APIs.

ol

  li#step-01
    h2 Starting a new brunch project
      small  The beginning of all good story

    :markdown
      To start a client-only app easily, I suggest using tools like [Brunch](http://brunch.io),
      [Yeoman](http://yeoman.io/) or [ngTailor](http://lauterry.github.io/ngTailor/).

      Let's use Brunch and generate a project based on the [@vbrajon](http://vbrajon.fr)'s
      [brunch skeleton](https://github.com/vbrajon/brunch-skeleton):

          brunch new gh:vbrajon/brunch-skeleton kewl-app
          cd kewl-app
          brunch watch --server

      And watch your app live on http://localhost:3333 !

    .tip
      :markdown
        You can publish you client-side app really easily on Github pages by inititing a repo in your `public` folder,
        switching to gh-pages branch, commiting all files there and pushing to your repo on Github.
        See the README file for more info.


  li#step-02
    h2 Creating our backend with Express
      small  Love at the first sight

    :markdown
      Let's create some backend for our brand new Angular app.
      Having a REST API as a backend is a great choice, as it's allow other developers to create easily new fontends to
      use the data it exposes (native mobile apps, desktop apps,...) and interacts with others services.
      The easy syntax of [Express.js](http://expressjs.com/) will help us creating one easily.

      ### Serving our front-end with Express
      As Brunch's basic server do, we need to send the user our static files (the Angular frontend).
      After Express's install with `npm install express --save`, we create a new `server/api.coffee` file containing :

          express = require 'express'
          path = require 'path'

          # Configuration
          api = express()
          api.set 'title', 'Kewl'

          # Frontend static files
          api.use express.static path.join __dirname, '../public'
          api.get '/', (req, res) ->
            res.sendfile 'index.html',
            root: path.join __dirname, '../_client'

          # API routes
          # Will come later!

          # Functions to start and stop the server
          api.start = (port = 3333, path, callback) ->
            api.listen port, callback
            console.log 'Server listening at port ' + port
          api.stop = (callback) ->
            api.close callback

          # Starting our server
          api.start()

      We can than start our server with `./node_modules/.bin/coffee server/api.coffee`.

    .tip
      :markdown
        By installing globally CoffeeScript (`npm install -g coffeescript`), you can use only `coffee server/api.coffee`.

    :markdown
      #### Integrating Express with Brunch
      As Brunch provide us an easy development server, we might want to continue using our `brunch watch --server` to
      be the only requirement to start the app.
      In Brunch config file `config.coffee`:

          exports.config =
            server:
              path: 'server/server.coffee'

      And in `server/server.coffee` :

          # Called by brunch --server
          api = require './api'
          module.exports =
            startServer: api.start
            stopServer: api.stop

      Now, `brunch watch --server` starts our Express serving our frontend, so the line `api.start()` is no longer
      desired in `server/api.coffee`.

      ### Some basic routes
      In this example, we'll create the most basic REST API of the world: one that handles a list of To Dos.

    .note
      :markdown
        In a nutshell REST services are built around fours verbs:
        - `GET` to aquire data
        - `POST` to add data
        - `PUT` to update data
        - `DELETE` to remove data

        E.g., to acquire this webpage's content, your browser is doing a `GET` request to the server that respond
        with the code of the webpage. Same for the pictures, the fonts...
        When you're submitting a form, it's generally a `POST` request.

        Request are addressed to an URL and can contain some extra data:

            POST http://my-awesome-website.com/newsletter/subscription
            {
              email: 'give-me-spam@me.com'
            }

    :markdown
      Let's implement a very easy example: a ToDo list.
      Consider an array of ToDos like this:

          [
              id: 0
              title: 'Buy chocolates'
              details: 'Prefer the ones without liquor'
              done: false
            ,
              id: 1
              title: 'Buy flowers'
              details: 'She prefers yellow ones'
              done: false
            ,
              id: 2
              title: 'Write a note'
              details: 'To be put in the flowers'
              done: true
          ]

      We need the following routes:
      - `GET /todo` will send the list
      - `POST /todo` will add an item
      - `DELETE /todo/:id` will mark an id as done

      Express makes easy to create this routes easily:

          _ = require "lodash" # Needed for _.find method

          # Configuration
          api.use express.bodyParser() # Populates req.body

          # To do storage
          id = 2
          toDoList = []

          # API routes
          api.get '/todo', (req, res, next) ->
            res.send toDoList

          api.post '/todo', (req, res, next) ->
            newToDo = req.body
            newToDo.done = false
            id = id+1
            newToDo.id = id
            toDoList.push newToDo
            res.send newToDo

          api.del '/todo/:id', (req, res, next) ->
            toDoItem = _.find toDoList, id: parseInt(req.params.id)
            toDoItem.done = true
            res.send toDoItem

    .tip
      :markdown
        API are testable without any frontend with tools like [POSTMAN](http://getpostman.com).

    :markdown
      ### Angular way of interacting with the API
      As interaction between a REST API is a common pattern in Angular apps, a module called
      [ngResource](http://docs.angularjs.org/api/ngResource) provides us a useful `$resource` service to map objects
      described in the API.

      To install ngResource module:

          bower install angular-resource
          cd vendor
          ln -s ../bower_components/angular-resource/angular-resource.js 17-angular-resource.js

    .note
      :markdown
        Brunch normally uses the `main` attribute from `.bower.json` to detect the file he needs to include in vendors
        (it's the strategy used by the [angular-brunch-seed](https://github.com/scotch/angular-brunch-seed).
        Symlinking the files we want to include seems better to me though as we can inlude other files, control their
        order (also possible with `before` and `after` attributes in brunch's `config.coffee`) and avoid Brunch's warning when
        a `.bower.json` is missing (which is often the case).

    :markdown
      Let's create a new module `kewl.todo` in our app in a `toDo` folder ([modularized folder
      structure](http://www.johnpapa.net/angular-growth-structure/)):

    tabset
      tab(heading='todo/todo.coffee')
        pre.
          todo = angular.module 'kewl.todo', ['ng', 'ngRoute', 'ui.bootstrap', 'ngResource']

          todo.config [
            '$routeProvider'
            ($routeProvider) ->
              $routeProvider
              .when '/todo', templateUrl: 'todo/todo.html', controller: 'toDoController'
                ]
                todo.controller 'toDoController', [
            '$scope', 'ToDoList'
            ($scope, ToDoList) ->
            $scope.toDoList = ToDoList.query()
          ]

          todo.factory 'ToDoList', [
              '$resource'
              ($resource) ->
                $resource 'todo/:id'
            ]
      tab(heading='todo/todo.jade')
        pre.
          h1 To do list

          accordion
          accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
            accordion-heading {{toDo.title}}
            {{toDo.details}}
      tab(heading='todo/todo.less')
        pre.
          .to-do {
            &.done {
              .text-muted;
              .panel-heading {
                .text-muted;
                text-decoration: line-through;
              }
            }
          }

    :markdown
      That handles display of tasks. We still need to create the front-end for POST/DELETE requests:

    tabset
      tab(heading='todo/todo.coffee')
        pre.
          todo.controller 'toDoController', [
            '$scope', 'ToDoList'
            ($scope, ToDoList) ->
              $scope.refreshToDoList = ->
                $scope.toDoList = ToDoList.query()

              $scope.sendButtonDisabled = false
              $scope.newToDo =
                title: ""
                details: ""

              $scope.addNewToDo = ->
                $scope.sendButtonDisabled = true
                ToDoList.save $scope.newToDo, ->
                  $scope.newToDo =
                    title: ""
                    details: ""
                $scope.sendButtonDisabled = false
                $scope.refreshToDoList()

              $scope.markAsDone = (toDoItem) ->
                ToDoList.delete
                  id: toDoItem.id
                , ->
                  $scope.refreshToDoList()

               $scope.refreshToDoList() # Load the to-do list for the first time
             ]
      tab(heading='todo/todo.jade')
        pre.
          h1 To do list

          accordion
            accordion-group.to-do(ng-repeat='toDo in toDoList', ng-class='{done: toDo.done}')
              accordion-heading {{toDo.title}}
                button.mark-as-done(ng-click='markAsDone(toDo)')
                  i.icon.icon-check
              {{toDo.details}}
            accordion-group.to-do.new
              accordion-heading
                .row
                  input.title(type='text', placeholder='Add a new task...', ng-model='newToDo.title')
                  button.send(ng-click='addNewToDo()', ng-disabled='sendButtonDisabled')
                    i.icon.icon-plus
                    |  Send
              textarea(placeholder='More details?', ng-model='newToDo.details')

      tab(heading='todo/todo.less')
        pre.
          .to-do {
            .mark-as-done {
              .btn;
              .btn-success;
              .pull-right;
              padding: @padding-xs-vertical/2 @padding-xs-horizontal;
            }

            &.done {
              .text-muted;
              .panel-heading {
                .text-muted;
                text-decoration: line-through;
              }
            }

            &.new {
              .title {
                .form-control;
                .make-xs-column(8);
                .make-sm-column(10);
              }
            .send {
                .btn;
                .btn-primary;
                .make-xs-column(4);
                .make-sm-column(1);
                .make-sm-column-offset(1);
              }
            textarea {
                .form-control;
              }
            }
          }

    :markdown
      At this point, our to-do list is fully functionnal, except for a little flickering when the object `toDoList` is
      queried. To avoid that effect, only affect `$scope.toDoList` when the server has answered:

          $scope.refreshToDoList = ->
            ToDoList.query (response) -> # function that will be called on success
              $scope.toDoList = response

  li#step-03
    h2 Interceptors saving the user from silence
      small  Angular/API communication therapy

    :markdown
      As user, when interacting with the server or changing route, we'll like to be informed that something is happening
      behind the scene. The usual UX pattern when requesting something through the web is to have a loading indicator,
      from the browser: ![Loading indicator from Chromium](img/loading-indicator-chromium.png)

      When loading asynchronous data without refeshing the webpage (AJAX calls) like Angular does, these indicators are
      not triggered.

      Fortunatly, Angular provides [interceptors](http://docs.angularjs.org/api/ng/service/$http#interceptors) to catch
      requests before and after they're sent.

      #### Implementing a loading indicator
      Interceptors are stored in the `$httpProvider.interceptor`. They are registered using `$httpProvider` like this:

          $provide.factory 'myHttpInterceptor', ->
            request: (request) ->
              # Do something when sending the request
              request

            response: (response) ->
              # Do something when recieving the response
              response

          $httpProvider.interceptors.push 'myHttpInterceptor'

      To implement a loading indicator, we can add to our `app.coffee`:

          app.factory 'loadingInterceptor', [
            '$rootScope'
            ($rootScope) ->
              request: (request) ->
                # Do something when sending the request
                $rootScope.loading = true
                request
              response: (response) ->
                # Do something when recieving the response
                $rootScope.loading = false
                response
          ]

          app.config [
            '$routeProvider', '$locationProvider', '$httpProvider'
            ($routeProvider, $locationProvider, $httpProvider) ->
              [...]
              # Register loading intercetor
              $httpProvider.interceptors.push 'loadingInterceptor'
          ]

      The `$rootScope.loading` variable can now be used to display an indicator, like the corner indicator from
      [creative loading effects](http://tympanus.net/Development/CreativeLoadingEffects/):

    tabset
      tab(heading='index.jade')
        pre.
          body
            [...]
            .loading-indicator(ng-show='$root.loading')
            [...]

      tab(heading='app.less')
        pre.
          .loading-indicator {
            @loading-indicator-size: 300px;

            position: fixed;
            top: 0;
            right: 0;

            width: @loading-indicator-size;
            height: @loading-indicator-size;
            background: @navbar-default-bg;
            background: rgba(red(@navbar-default-bg), green(@navbar-default-bg), blue(@navbar-default-bg), 0.7);
            .transition(all 0.3s);
            -webkit-transform: translateX(50%) translateY(-50%) rotate(45deg);
            transform: translateX(50%) translateY(-50%) rotate(45deg);
            pointer-events: none;

            @circles-color-1: #fff;
            @circles-color-2: @brand-primary;
            &::before,
            &::after {
              position: absolute;
              bottom: @loading-indicator-size/10;
              left: @loading-indicator-size/2;
              display: block;
              border: 5px solid @circles-color-1;
              border-radius: 50%;
              content: '';
            }

            @big-circle-size: @loading-indicator-size*8/30;
            &::before {
              margin-left: -@big-circle-size/2;
              width: @big-circle-size;
              height: @big-circle-size;
              border-right-color: @circles-color-2;
              border-left-color: @circles-color-2;
              -webkit-animation: rotation 3s linear infinite;
              animation: rotation 3s linear infinite;
            }

            &::after {
              @small-circle-size: @big-circle-size/2;
              bottom: 50px;
              margin-left: -@small-circle-size/2;
              width: @small-circle-size;
              height: @small-circle-size;
              border-top-color: @circles-color-2;
              border-bottom-color: @circles-color-2;
              -webkit-animation: rotation 1s linear infinite;
              animation: rotation 1s linear infinite;
            }

            @-webkit-keyframes rotation {
              0% {
                -webkit-transform: rotate(0deg);
              }
              50% {
                -webkit-transform: rotate(180deg);
              }
              100% {
                -webkit-transform: rotate(360deg);
              }
            }

            @keyframes rotation {
              0% {
                transform: rotate(0deg);
              }
              50% {
                transform: rotate(180deg);
              }
              100% {
                transform: rotate(360deg);
              }
            }
          }

    :markdown
      As our server is local, we may not have enought time to see the loader is actually working. We can add a delay
      before our Express server to simulate some network latency:

          # Simulate network latency
          waitOneSecond = (req, res, next) ->
            setTimeout next, 1000

          # API routes
          api.get '/todo', waitOneSecond, (req, res, next) ->
            res.send toDoList

          api.post '/todo', waitOneSecond, (req, res, next) ->
            [...]
            res.send newToDo

          api.del '/todo/:id', waitOneSecond, (req, res, next) ->
            toDoItem = _.find toDoList, id: parseInt(req.params.id)
            [...]
            res.send toDoItem


